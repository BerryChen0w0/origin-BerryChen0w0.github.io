---
layout: post
title: "杂记心得"
date: 2024-04-15
---

这里写一些还没整理成文的小心得，或者是一些小知识

## 个人理解
### 如何理解一个zk协议
理解一个zk协议，一般倒着看比较容易。例如sum-check,GKR,lec7[22/48]的step1，都是这样。前一个check/步骤中常常有一些“假设xxx成立”的前提，而这些前提是在后一个check/步骤中进行验证的。所以反过来看则容易理解整个协议（主要是协议的soundness，即为什么这样构造就可以保证P大概率无法造假）

> 以GKR为例，第i个iteration中V最后需要知道$W_{i+1}(b*),W_{i+1}(c*)$的值，而这两个值只能由P提供。这里可以理解为假设P正确提供了这两个值。但实际上P可能骗人，于是需要验证这两个值是否正确，怎么验证？就是用第i+1个iter。
> 
> 接着第i+1个iter也要基于“$W_{i+1}$正确”的假设，这个假设需要第i+2个iter验证。如此下去，直到最后一个iter，此时V可以自己求出$W_d(x)$了，从而能够完成$W_d$正确性的验证，于是$iter_{d-1}$的假设就能站住脚，于是一路反推，所有的iter的假设都可以站住脚，整个协议的soundness逻辑才稳固下来
> 
> 所以，正着看是协议运行过程，倒着看才是协议的soundness逻辑【不过要构造协议的话，应该也是正着走思路的，其实就是需要一个递归的思想，或者说动态规划的思想。我这方面的思想还很弱，才出现正着看理解soundness有困难的情况】

### 理解zkp各种定义（知识论证、提取器等等）中的Oracle
把某个角色（例如Prover, Verifier, Extractor等等）视作一个Oracle与其交互，本质上是为了保证这个角色绝对严格按照expected behavior来做。例如如果是一个Verifier被作为Oracle（例如在“零知识性”的定义中，Simulator和一个Oracle的Verifier交互，记为$Sim^{\mathcal{V}}(x)$【小括号里的输入内容不确定，是不是还有其他参数作为输入？】），则这个V必须是诚实的V；而如果是“任意PPT敌手$\mathcal{P}^*$，存在期望PPT的提取器$\mathcal{E}$，...，$\mathcal{E}^{\mathcal{P}*}(x)$...”这样（中文综述9/69定义14），则这个放在Oracle位置上的$\mathcal{P}*$，就是严格按照这个PPT敌手该做事情来行动，它可能是不诚实的P（因为是敌手，可能试图骗过V，不按照zk协议规定的行动方式来行动）

### NP,IP,IOP的演化
是逐渐增加P的计算成本，以实现V的成本降低的过程【我在哪里写过了，是overleaf？】

## 一些小知识
* wlg给的indistinguishable的例子
* 其他一些和wlg交流得到的知识【例如各种协议，构造，还有上周关于指数上的域元素以及其他的讨论】